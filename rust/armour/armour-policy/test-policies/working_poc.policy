external logger @ "log_sock" {
  fn log(_) -> ()
  fn connection(str, ID, ID) -> ()
  fn tcp_connection(ID, ID) -> ()
}

// REST request allow/deny
fn allow_rest_request(req: HttpRequest) -> bool {
  logger::log("request", req);
  let (from, to) = req.connection().from_to();
  if let Some(date) = req.unique_header("date") {
     logger::connection(str::from_utf8(date), from, to)
  } else {
     logger::connection("-", from, to)
  };
  true
}

// TCP connection/deny
fn allow_tcp_connection(c: Connection) -> bool {
  logger::log("connection", c);
  true
}


fn test_connection(from: ID, to: ID) -> bool {
  let from_hosts = from.hosts();
  let to_hosts = to.hosts();

  let allow = ["debug", "launch"];
  let mongo = ["mongo-web-interface", "accounting"];
  let mysql_from = ["dbread", "dbwrite"];
  let mqtt = ["mqtt-trusted","mqtt-debug","mqtt-public"];
  let dtp = ["pulse", "notifications"] @ mongo @ mqtt;
  let untrusted = ["picolibri", "pipharm"];
  let verify = ["verify-id"];
  let mysql_to = ["mysql"] @ verify;
  let on_during = ["on-during-conversation"];
  let cloud = ["cloud-update"];

  if !to_hosts.is_disjoint(mqtt) {
    !from_hosts.is_disjoint(allow @ ["dtp"] @ mqtt @ untrusted @ verify @ on_during)
  } else if !to_hosts.is_disjoint(dtp) {
    "dtp" in from_hosts
  } else if "mongo" in to_hosts {
    !from_hosts.is_disjoint(mongo)
  } else if !to_hosts.is_disjoint(mysql_to) {
    !from_hosts.is_disjoint(mysql_from @ allow)
  } else if !to_hosts.is_disjoint(["dtp"] @ verify @ on_during @ mysql_from @ cloud) {
    !from_hosts.is_disjoint(allow)
  } else { false}
}

//L7 policy, test for dtp container
//fn dtp_connection(req: HttpRequest, from: ID, to: ID) -> bool {

//  let to_hosts = to.hosts();
//  let mqtt = ["mqtt-trusted","mqtt-debug","mqtt-public"];
//  let dtp = ["pulse", "mongo-web-interface", "accounting", "notifications"] @ mqtt;

//  "dtp" in from.hosts() && any to_host in to_hosts { to_host in dtp }
//  &&
//  (req.method() == "POST" && req.path() == "poc/api/v1.0/notifications")
//}
