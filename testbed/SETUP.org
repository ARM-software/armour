* Setup a docker-machine
** Create the machine
#+BEGIN_SRC bash
docker-machine create armour
#+END_SRC
** Set up the docker environment to the docker machine
#+BEGIN_SRC bash
eval (docker-machine env armour)
#+END_SRC
** ssh into the machine 
#+BEGIN_SRC bash
docker-machine ssh armour
#+END_SRC
** Set up a shared directory with the VM host [[https://docs.docker.com/machine/reference/mount/][(docker-machine mount)]]
- Requires sshfs
#+BEGIN_SRC bash
docker-machine ssh armour mkdir armour-playground
docker-machine mount ./armour-playground armour:/dm-mount-point/
#+END_SRC
- This solution is only temporary, to make it permanent add a rule to the VBox machine settings
* Dockerfiles
** dockerfile-client-python
- Creates a simple image which can run python servers
- Exposes port 8080 // This is actually not necessary since it will be
  taken care of by the ip-tables rules
- mounts the armour-playground directory above (where python files are stored)
* docker-compose file
** Rebuild images if necessary
#+BEGIN_SRC bash
docker-compose build
# docker-compose up -d build
#+END_SRC
** Run the images
#+BEGIN_SRC bash
docker-compose up -d
#+END_SRC
** Set up the iptables rules
#+BEGIN_SRC bash
docker-machine ssh armour
sudo sh /dm-mount-point/iptables-setup.sh
exit
#+END_SRC
** Armour-playground
- All images mount the armour-playground directory where both the
  servers and infrastructure binaries are stored to be updated from
  the host and reduce development setup time
** Testing example (03-04-2019 no filtering, only proxying):
- Cargo target should be in to $SFPL/sfpl2-drafts/armour-playground/cargo-target/
- run a server in server-1:
#+BEGIN_SRC bash
docker exec -it server-1 python3 /flask-server/server.py -d
#+END_SRC
  -- TODO: use DNS to avoid hardcoded IPs
- get the ip address of server-1 and server-2
#+BEGIN_SRC bash
docker exec -it server-1 ip addr show dev eth0 | grep inet | cut -f1 -d '/'
docker exec -it server-1 ip addr show dev eth0 | grep inet | cut -f1 -d '/'
#+END_SRC
- make a request in server-2
#+BEGIN_SRC bash
docker exec -it server-2 curl http://10.4.0.2:8080/
#+END_SRC
- Run the proxy in a different terminal
#+BEGIN_SRC bash
docker exec -it proxy /armour-playground/cargo-target/x86_64-unknown-linux-musl/debug/arm-proxy -i eth0
#+END_SRC
- Repeat the request
#+BEGIN_SRC bash
docker exec -it server-2 curl http://10.4.0.2:8080/
#+END_SRC
It should fail with a forward error at this point
- Allow the request:
#+BEGIN_SRC bash
docker exec -it proxy curl http://10.3.0.2:8444/allow/10.5.0.2/10.4.0.2/8080
#+END_SRC
- Repeat the request
#+BEGIN_SRC bash
docker exec -it server-2 curl http://10.4.0.2:8080/
#+END_SRC
It should succeed!
- Repeat the process with each of the client/servers needed

* Setting up Rust for cross-compilation
** [[https://grahamenos.com/rust-osx-linux-musl.html][Cross Compiling Static Rust Binaries for Linux on OS X Â· Graham Enos]]
** [[https://blog.filippo.io/easy-windows-and-linux-cross-compilers-for-macos/][Easy Windows and Linux cross-compilers for macOS]]
** [[https://chr4.org/blog/2017/03/15/cross-compile-and-link-a-static-binary-on-macos-for-linux-with-cargo-and-rust/][Cross-compile and link a static binary on macOS for Linux with cargo and rust - chr4]]

